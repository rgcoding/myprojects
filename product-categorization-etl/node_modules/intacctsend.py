# -*- coding: utf-8 -*-
"""
Created on Mon Oct 19 15:35:30 2020
Helps connect to, get session, and send data to Intacct 
@author: Natasha.Polishchuk
"""

import pandas as pd
import numpy as np
import requests 
import xml.etree.ElementTree as ET
import time

"""Variables"""

# api credentials - temp, move to more secure storage before checking in
url = 'https://api.intacct.com/ia/xml/xmlgw.phtml'
company_id = 'Cresco-sandbox' #replace with prod credentials when live
sender_id = 'Cresco Labs'
sender_password = 'jpt7RTk5SDTXTf+mV+jQIxRxAnJ1W8Z'
user_id = 'NPolishchuk' 
user_password = 'Cl0353Int?!'
ts = time.time()
yr = time.strftime('%Y')
mo = time.strftime('%m')
dy = time.strftime('%d')
control_id = str(int(ts)) 
session_function_id = '161702f2-90b0-48bf-a919-20971edacecc'
function_id = '5c7623a8-9bf8-471b-a86a-791f49ffcafb' #random guid to uniquely identify functions for recovery purposes
headers = {
      'Content-Type': 'application/xml'
    }


"""Functions"""
def get_session_id():
    # returns a token to call the intacct api
    payload = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<request>\r\n  <control>\r\n    <senderid>"+sender_id+"</senderid>\r\n    <password>"+sender_password+"</password>\r\n    <controlid>"+control_id+"</controlid>\r\n    <uniqueid>false</uniqueid>\r\n    <dtdversion>3.0</dtdversion>\r\n    <includewhitespace>false</includewhitespace>\r\n  </control>\r\n  <operation>\r\n    <authentication>\r\n      <login>\r\n        <userid>"+user_id+"</userid>\r\n        <companyid>"+company_id+"</companyid>\r\n        <password>"+user_password+"</password>\r\n      </login>\r\n    </authentication>\r\n    <content>\r\n      <function controlid=\""+session_function_id+"\">\r\n        <getAPISession />\r\n      </function>\r\n    </content>\r\n  </operation>\r\n</request>"
    response = requests.request("POST", url, headers=headers, data = payload)
    root = ET.fromstring(response.content)
    for item in root.findall('./operation/result/data/api/sessionid'):
        session_id_list = str(item.text.encode('utf8')).split("'")
    try:
        session_id = session_id_list[1]
    except UnboundLocalError:
        print("Could not log into Intacct. Check credentials")
    print("Session ID:",session_id)
    return session_id


def create_orders_XML(df):
    #build a tree structure that can easily convert to the special legacy Orders XML 
    #Different from every other type of object
    
    session_id = get_session_id()
    
    #The order of fields matters
    orderCols = ['customerid','message','state']
    itemCols = ['itemid','quantity','unit','price','locationid','departmentid','classid']
    
    df = df.loc[:, ~df.columns.str.contains('^Unnamed')]
    df.sort_values(by = ['id'],inplace =True)
    df = df.astype(str)
    
    idMarker = df['id'][0]
    root = None
    ord_results = []
    
    for i, row in df.iterrows():
        #order info is repeated in each line, so only need to add once
        if row['id'] != idMarker or root is None:
            if root is not None:
                transXML = ET.tostring(root, 'utf-8', method="xml").decode("utf-8")
                # have to send each order one by one, Intacct errors with bulk load
                result = write_to_intacct(transXML,session_id)
                ord_results.append([idMarker,result])
            idMarker = row['id']
            root = ET.Element('create_sotransaction') 
            transtype = ET.SubElement(root, 'transactiontype')
            try:
                transtype.text = row['transactiontype']
            except KeyError:
                transtype.text = 'Sales Order'
                
            date_created = ET.SubElement(root, 'datecreated')
            # If no date provided, use today
            year = ET.SubElement(date_created, 'year')
            try:
                year.text = row['year']
            except KeyError:
                year.text = yr
            month = ET.SubElement(date_created, 'month')
            try:
                month.text = row['month']
            except KeyError:
                month.text = mo
            day = ET.SubElement(date_created, 'day')
            try:
                day.text = row['day']
            except KeyError:
                month.text = dy
                
            for parent in orderCols:
                try:
                    order_detail = ET.SubElement(root, parent)
                    order_detail.text = row[parent]
                except KeyError:
                    pass
                   
            items = ET.SubElement(root, 'sotransitems')
        
        #item info is unique, so add for each row
        item_each = ET.SubElement(items, 'sotransitem')
        for child in itemCols:
            try:
                item_detail = ET.SubElement(item_each, child)
                item_detail.text = row[child]
            except KeyError:
                pass
    
    transXML = ET.tostring(root, 'utf-8', method="xml").decode("utf-8")        
    result = write_to_intacct(transXML,session_id)   
    ord_results.append([idMarker,result])
    
    return ord_results

def write_to_intacct(payobj,session_id):
    # Send the payload and write back the response
    
    payload = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<request><control><senderid>"+sender_id+"</senderid><password>"+sender_password+"</password> <controlid>"+control_id+"</controlid><uniqueid>false</uniqueid><dtdversion>3.0</dtdversion><includewhitespace>false</includewhitespace></control> <operation> <authentication><sessionid>"+session_id+"</sessionid></authentication><content><function controlid=\""+function_id+"\">" +payobj+"</function> </content> </operation> </request>"
  
    report_str = requests.request("POST", url, headers=headers, data = payload)
    response_xml = ET.fromstring(report_str.content)
    result = response_xml.find('./operation/result/status')
    status = result.text
    if status == 'failure':
        error = response_xml.find('./errormessage/error/description2').text
        return status,error
    elif status == 'success':
        key = response_xml.find('./operation/result/key')
        order_key = key.text
        return status,order_key
    return status,''